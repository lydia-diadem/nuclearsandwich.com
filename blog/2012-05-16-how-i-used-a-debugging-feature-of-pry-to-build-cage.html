<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="/stylesheets/normalize.css"/>
    <link rel="stylesheet" href="/fonts/sansumi/font.css"/>
    <link rel="stylesheet" href="/fonts/bitter/font.css"/>
    <link rel="stylesheet" href="/fonts/anonymous/font.css"/>
    <link rel="stylesheet" href="/stylesheets/main.css"/>
    <title>Nuclearsandwich!</title>
  </head>
  <body>
    <header class="page">
      <h1>The Mad Ramblings of a Lunatic Hacker</h1>
      <h2>An Exercise in Wit or Vanity</h2>
    </header>
    <nav>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about.html">About</a></li>
    <li><a href="/blog">Blog</a></li>
    <li><a href="https://github.com/nuclearsandwich">GitHub</a></li>
    <li><a href="/cage">Cage</a></li>
  </ul>
</nav>

    <div class="content">
      <article>
  <header>
    <h1>How I Used a "Debugging Feature" of Pry to Build Cage</h1>
    <h2>published: 16 May 2012 21:05:00PM</h2>
  </header>
  <p><a href="http://pry.github.com">Pry</a> is an alternative interactive Ruby environment
similar to IRB. In addition to looking a little nicer through nearly live
colorization, Pry offers some pretty powerful features for exploring, modifying,
and debugging Ruby applications in a live system.</p>

<p>Pry&#39;s namesake ability to &quot;pry&quot; open an object is not limited to debugging use.
It&#39;s actually a really straightforward way to build any kind of domain specific
REPL. I think I just coined that term but it fits well and you&#39;ll soon see why.</p>

<h2>The Backstory</h2>

<p>When I working at <a href="http://nowbox.com">NOWBOX</a> I spent a lot of time hitting our
API during ad-hoc testing. I was doing enough of this that just using curl
wasn&#39;t cutting it.</p>

<p>Don&#39;t get me wrong, curl is awesome and super useful. But it lacks a few
niceties. Chief among them curl, like HTTP, is stateless without the use of
cookie files and given that we were using a token-based authentication system,
simulating device-API interaction using exclusively curl was neither fun nor
easy.</p>

<p>During this time, we were also using
<a href="https://github.com/brynary/rack-test">Rack::Test</a>, which I really like. It&#39;s a
solid and purposeful DSL and great at what it does. What it isn&#39;t good at is
being interactive. I&#39;d get colourful explosions(stacktraces) whenever I tried to
pry into and look at a test using <code>Rack::Test</code>.</p>

<p>We already had the awesome <a href="https://github.com/technoweenie/faraday">Faraday</a>
included in our project, so I hacked together a quick rake task that would set
up a <code>Faraday::Connection</code> and pry into it. What did this get me? I now had my
interactive <code>Rack::Test</code>.</p>

<h3>Cage Version -1</h3>

<pre lang="ruby"><code># Rakefile
task :client_console do
  require &quot;faraday&quot;
  require &quot;pry&quot;
  uri = case ENV[&quot;target&quot;]
        when &quot;production&quot;
          &quot;http://api.superawesomepage.com/1/&quot;
        when &quot;staging&quot;
          &quot;http://api.staging.superawesomepage.com/1/&quot;
        else
          &quot;http://localhost:3000/1/&quot;
        end
  Faraday::Connection.new(uri).pry
end
</code></pre>

<h2>Building the Gem</h2>

<p>Pry made this really easy. So easy that later on, when I wanted to rewrite the
above code and turn it into a reusable gem I kept the same strategy.</p>

<p>I build my DSL class, <code>Cage::Console</code>, which also handles all the initialization
such as config file loading and default values for variables. It also overloads
some of Pry&#39;s settings to get a more interesting prompt string and suppressing
they default <code>~/.pryrc</code> config file loading.</p>

<pre lang="ruby"><code># lib/cage/console.rb
class Cage::Console
  def initialize config_file = nil
    configure_pry
    read_config_file File.expand_path config_file if config_file
    default_to_rubygems
    reinitialize_connection
  end

  ## The rest of the show
  ## ...
  ## The party starter
  def self.start! *args
    new(*args).pry
  end
end
</code></pre>

<p>The rest of the class is the domain specific stuff that deals with delegating to
the Faraday connection object and building the response object. I built my own
wrapper around Faraday&#39;s response so I could improve how they are displayed as
return values.</p>

<pre lang="ruby"><code># lib/cage/response.rb
class Cage::Response
  ## Delegating code
  ## ...
  ## Prettification code
  def inspect
    &lt;&lt;-PRETTY
Status: #{status}

Headers:
#{headers.map { |k, v| &quot;  #{k}: #{v}&quot; }.join &quot;\n&quot;}

Body:
  #{body}

#&lt;Cage::Response:(#{url})&gt;
      PRETTY
    end
  end
end
</code></pre>

<p>It&#39;s certainly verbose but the primary function is to show you the complete
result of an HTTP request, which it does.</p>

<h2>Concluding</h2>

<p>That&#39;s  basically all there is to it. This feature of Pry that&#39;s mainly
advertised as a way to get hands-on with your objects for debugging is also a
great way to build a domain specific or domain focused interactive environment.
Depending on how much you want to customize Pry&#39;s interface you don&#39;t even need
a thorough understanding of Pry&#39;s internals. If you&#39;re more interested in the
features <em>of</em> Cage than the mechanics of its construction you can install it
from RubyGems using <code>gem install cage</code> or check out its <a href="/cage">project page</a>.
The complete source for Cage is on
<a href="https://github.com/nuclearsandwich/cage">GitHub</a>. I hope you use Pry and Cage
to build awesome stuff!</p>

</article>

    </div>

    <footer>
      <p class="copyright">
        Copyright 2012 Steven! Ragnar√∂k.
        All rights reserved.
      </p>
    </footer>
  </body>
</html>
